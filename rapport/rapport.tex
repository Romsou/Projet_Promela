\documentclass[12pt, a4paper]{report}
\usepackage[utf8]{inputenc}
%\usepackage[scaled]{helvet}
%\renewcommand*\familydefault{\sfdefault}
\usepackage[french]{babel}
\usepackage{geometry}
\usepackage{fancyhdr}
\usepackage[svgnames]{xcolor}
\usepackage{enumitem}
\usepackage{algorithm}
\usepackage{algpseudocode}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{sectsty}


% Permet de changer la numérotation de la documentclass pour les sections
\renewcommand{\thesection}{\arabic{section}}

% Définition des listes
\frenchbsetup{StandardLists=true}
\setitemize{font=\color{SeaGreen}}

% Définition des marges (paquets geometry)
\geometry{margin=2.5cm, vmargin=2.5cm}

% Définition de l'indentation
\setlength{\parindent}{0cm}

% Couleur des sections et sous-sections
\sectionfont{\color{blue}}
\subsectionfont{\color{blue}}

\title{\color{blue}Projet d'introduction à la vérification}
\date{\today}
\author{Adrien Mollet\\ Romain Soumard}

\begin{document}
\maketitle

\section{Introduction}

Le présent document est un rapport écrit à l'issue du projet de fin d'année d'introduction à la vérification. Il a été rédigé par M.Adrien Mollet et M.Romain Soumard à l'université d'Aix-Marseille durant l'année scolaire 2019-2020.
Le but de ce projet consistait en la résolution de deux exercices:
\begin{itemize}
\item Exercice 1: Trouver la plus courte solution au problème du berger.
\item Exercice 2: Modélisation du jeu du solitaire à l'aide du langage Promela.
\end{itemize}
Les sections suivantes présenteront brièvement l'organisation du travail et la résolution de chaque exercice.

\section{Organisation du travail}

Le travail a été séparé en deux groupes. M. Soumard s'est chargé de l'exercice 1 tandis que M. Mollet s'est chargé de l'exercice 2. Le travail s'est fait via GitHub. Une fois les exercices terminés, une dernière session de travail s'est tenue afin d'harmoniser le rendu, nettoyer le code, et rajouter des script bash faisant office de makefile afin de faciliter la correction.

\section{Exercice 1: Problème du berger}

\subsection{Résolution du problème}

La résolution du problème du berger s'est faite en deux temps. Il a tout d'abord fallu trouver les caractéristiques de l'exécution que l'on désirait obtenir. Une fois ceci fait, il a fallut l'exprimer à l'aide d'une formule LTL.

Bien que dans un premier temps, nous exprimions la propriété à vérifier à l'aide d'un processus never, il nous est apparu en parcourant la documentation de spin qu'il était bien plus aisé d'exprimer directement la propriété recherchée dans le code. Il s'agit en effet de la méthode recommandée depuis spin 6, celle-ci étant plus propre et équivalente (la formule reste la même, elle n'est juste pas automatiquement niée quand on génère un processus never).

Après avoir trouver la formule appropriée, une longue phase de débugguage s'en est suivi pour comprendre pourquoi nous n'arrivions pas à générer le modèle approprié. Il s'est avéré que cela était dû à l'ordre dans lequel nous modélisions les traversées des différents protagonistes.

En effet, pour vérifier la propriété voulue, il était essentiel que le berger arrive avant ses amis sur la rive opposée dans notre modèle.

Une fois terminée, nous nous sommes aperçus que l'exécution engendrée par notre propriété produisait déjà une solution optimale (facile à vérifier à l'aide d'un graphe.). Nous avons donc généré un graphe de séquence de message (MSC) afin de compléter l'exercice.

\subsection{MSC du berger}

Vous trouverez ci-joint dans le fichier MSC\_berger.txt le MSC du problème du berger.

\section{Exercice 2: Modélisation du solitaire}

\subsection{Modélisation du problème de base}

La modélisation du solitaire européen classique fut une grosse partie de cet exercice : en effet, nous voulions une modélisation propre et modulable afin de préparer le terrain pour la deuxième partie de l'exercice où nous allions avoir à changer la forme et la taille du plateau.

\subsubsection{Premier jet}

Dans un premier temps, nous sommes partis sur la création d'une matrice pour représenter le plateau (le type matrice a été défini comme tableau de tableau avec un typedef). Chacune des cases de la matrice contient une valeur parmis les suivantes :
\begin{itemize}
\item 0 : la case est libre
\item 1 : la case est occupée
\item 2 : la case est interdite (cette dernière option permet de représenter n'importe quel plateau sous forme de matrice carrée, bien plus simple a gérer)
\end{itemize}
Nous avons conservé cette idée de matrice à état pour le reste de la modélisation.

Par la suite, et là se dessine un mauvais choix, nous avons programmé un processus pour initialiser le plateau avec les bonnes valeurs pour chaque case. C'est une erreur car cela ne permet pas de modularité au niveau du choix du plateau, mais également car il n'est pas nécessaire de faire appel a un processus pour cela, il y a bien plus simple. Cette approche sera donc retirée par la suite.

Ensuite, nous avons défini que chaque case serait représentée par un processus individuel. Nous n'avions a ce moment là aucune autre idée de comment gérer les coups possibles : nous avons donc décidé d'initialiser un processus par case vérifiant si un coup est jouable depuis celle ci, et de placer dans un channel ledit coup. Cette solution fonctionne convenablement lorsqu'il s'agit juste de laisser jouer le solitaire, mais elle crée des problèmes de consommation exponentielle de RAM lorsque l'on utilise pan pour trouver une solution au jeu. En effet, autant de processus et de possibilités font consommer beaucoup trop de mémoire à pan, qui essaye tant bien que mal d'appliquer son backtracking. Evidemment, cette partie de la modélisation à été remplacée par la suite.

Enfin, une partie de la modélisation que nous avons gardé (mais modifié plus tard) est un processus player. Ce processus attend un coup jouable sur un channel "rendez-vous" (coup envoyé par un des processus de case), puis joue ce coup là, modifiant le plateau en conséquence. Il attend ensuite un autre coup et continue sur le même principe. Ce processus sera modifié plus tard pour s'adapter a la disparition des processus de case.

Dans l'ensemble, cette première modélisation du problème fut plutôt instinctive et satisfaisant si on ne considère pas de formule LTL à vérifier, dans le sens où le "jeu" se déroule tout de même. Néanmoins, l'utilisation d'un processus par case est une grosse erreur menant à de nombreux soucis dès lors que l'on utilise pan.

Vous pouvez retrouver le code de cette première approche dans le fichier "solitaireV1.pml".

\subsubsection{Deuxième, troisième et quatrième jets}

Nous avons décidé de repartir du modèle précédent mais en tentant une autre approche.

Nous avons conservé l'idée de matrice, mais nous avons changé le principal problème du modèle précédent : la gestion des cases et des coups jouables. Nous avons migré du principe d'un processus par case, un processus player et un processus board vers une approche à seulement deux processus : board et player.

Le processus player est chargé d'attendre un signal du board par un channel rendez-vous, de récupérer une case vide dans le channel des cases vides, puis de générer un coup jouable de manière non déterministe. Si aucun coup n'est jouable il replace la case libre dans le channel des cases libres et en sélectionne une autre, et ce jusqu'à générer un mouvement valide. Il envoie ensuite ledit mouvement dans un channel de coup à jouer puis recommence le cycle en attendant un signal du plateau. Le player s'arrête lorsqu'une case libre est sélectionné trois fois sans être jouée.

Le plateau quant à lui initialise les bonnes valeurs pour le plateau, place la première case libre dans le channel adéquat puis attend un mouvement envoyé par le player. Lorsqu'il reçoit un coup, board le joue, modifiant le plateau en conséquence, décrémentant le nombre de pions restants et ajoutant les cases nouvellements libérées au bon channel. Il recommence ensuite son cycle en attendant un nouveau coup à jouer.

Nous avons regroupé dans cette section les versions 2, 3 et 4 car le modèle est sensiblement le même. La version 4 n'est qu'une réécriture plus propre de la version 2, et souffre des mêmes problèmes (voir plus loin). La version 3 quant à elle est plus particulière. En effet plutôt que de rendre impossible la génération de coups interdits directement dans le modèle, nous avons essayé (sans succès) d'utiliser une formule LTL à cet effet.
Les différentes versions sont trouvables respectivements sous les noms "solitaireV2.pml", "solitaireV3.pml" et "solitaireV4.pml".

\subsubsection{Problème récurrent}

Malgré nos différentes approches et modélisations, un problème est resté et nous n'avons pas réussi à le corriger. Lors de l'exécution de pan pour chercher une solution au jeu, la mémoire vive est à chaque fois saturée et le calcul ne donne pas de .trail montrant une résolution du jeu.

Ce problème peut être dû a deux élements :
\begin{itemize}
\item Le modèle n'est pas assez contraint par notre formule LTL. En effet, !(<>(number_pegs == 1)) n'est peut être pas suffisant à pan pour élaguer suffisamment l'arbre des possibilités.
\item Notre modèle est trop complexe et comprend trop d'opérations, saturant l'algorithme de calcul de pan.
\end{itemize}
Nous avons essayé de plus contraindre le modèle dans solitaireV3 et nous avons essayé de simplifier dans solitaireV2 et solitaireV4 mais rien n'y fait, impossible d'avoir une résolution du jeu.

\subsection{Gestion d'autres plateaux}

Conformément au sujet, nous avons réalisé un script ("board_generator.py") permettant de choisir le type de plateau et de générer le programme Promela adéquat. Il est possible de choisir un plateau européen, anglais ou allemand et d'en choisir la taille.

Au vu des problèmes de résolution de notre solitaire dans sa version de base, nous n'avons évidemment pas pu tester la résolution sur des plateaux plus grands. Néanmoins nous avons tout de même tenu à faire le script permettant de faire cette partie du projet.

Nous vous renvoyons maintenant au README pour le fonctionnement de notre projet.

\section{Conclusion}

En conclusion, nous aimerions mentionner que c'était un projet très intéressant et instructif à effectuer. Découvrir la vérification et les élements essentiels de cette branche de l'informatique fut très enrichissant. Néanmoins les outils spin et surtout Promela opérants dans un paradigme peu familier nous ont parfois posé des difficultés, surtout au niveau conception/modélisation (en témoigne notre modèle du solitaire dont pan ne parvient pas à tirer de solution satisfaisant notre formule LTL). Malgré nos accrochages avec le langage et le logiciel utilisés, ce fut un très bon projet que nous sommes ravis d'avoir réalisé.

\end{document}
