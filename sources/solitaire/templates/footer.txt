

hole.line = first_hole_line; hole.column = first_hole_column;
free_holes!hole;
ready!1;}
wait_move : atomic{move_to_play?current_move ->
 if
 ::(current_move.direction == UP) ->
    printf("Playing [%d,%d,UP]\n",current_move.line_number,current_move.column_number);
    matrix[current_move.line_number-2].column[current_move.column_number] = 0;
    matrix[current_move.line_number-1].column[current_move.column_number] = 0;
    matrix[current_move.line_number].column[current_move.column_number] = 1;
    hole.column = current_move.column_number;
    hole.line = current_move.line_number-2;
    free_holes!hole;
    hole.line = current_move.line_number-1;
    free_holes!hole;
    number_pegs = number_pegs - 1;
    ready!1; goto wait_move;
 ::(current_move.direction == DOWN) ->
    printf("Playing [%d,%d,DOWN]\n",current_move.line_number,current_move.column_number);
    matrix[current_move.line_number+2].column[current_move.column_number] = 0;
    matrix[current_move.line_number+1].column[current_move.column_number] = 0;
    matrix[current_move.line_number].column[current_move.column_number] = 1;
    hole.column = current_move.column_number;
    hole.line = current_move.line_number+2;
    free_holes!hole;
    hole.line = current_move.line_number+1;
    free_holes!hole;
    number_pegs = number_pegs - 1;
    ready!1; goto wait_move;
 ::(current_move.direction == LEFT) ->
    printf("Playing [%d,%d,LEFT]\n",current_move.line_number,current_move.column_number);
    matrix[current_move.line_number].column[current_move.column_number-2] = 0;
    matrix[current_move.line_number].column[current_move.column_number-1] = 0;
    matrix[current_move.line_number].column[current_move.column_number] = 1;
    hole.line = current_move.line_number;
    hole.column = current_move.column_number-2;
    free_holes!hole;
    hole.column = current_move.column_number-1;
    free_holes!hole;
    number_pegs = number_pegs - 1;
    ready!1; goto wait_move;
 ::(current_move.direction == RIGHT) ->
    printf("Playing [%d,%d,RIGHT]\n",current_move.line_number,current_move.column_number);
    matrix[current_move.line_number].column[current_move.column_number+2] = 0;
    matrix[current_move.line_number].column[current_move.column_number+1] = 0;
    matrix[current_move.line_number].column[current_move.column_number] = 1;
    hole.line = current_move.line_number;
    hole.column = current_move.column_number+2;
    free_holes!hole;
    hole.column = current_move.column_number+1;
    free_holes!hole;
    number_pegs = number_pegs - 1;
    ready!1; goto wait_move;
 fi
   }
}

// Processus correspondant au joueur
// Ce processus doit:
// - Lire une case libre de free_holes
// - Envoyer une direction au board.
proctype player() {
Hole current_hole;
wait_signal : ready?1;
choose_hole : atomic{ free_holes?current_hole ->
  printf("Hole selected");
  to_send_move.line_number = current_hole.line;
  to_send_move.column_number = current_hole.column;
  if
   :: (0<=to_send_move.line_number-2) -> to_send_move.direction = UP;
   :: (to_send_move.line_number+2<board_height) -> to_send_move.direction = DOWN;
   :: (0<=to_send_move.column_number-2) -> to_send_move.direction = LEFT;
   :: (to_send_move.column_number+2<board_height) -> to_send_move.direction = RIGHT;
  fi
  move_to_play!to_send_move;
  printf("Move sent");
  goto wait_signal;
}
}

init
{
atomic{run board(); run player();}
}

/* Formule LTL exploitant les possibilitÃ©s de spin 6 */
ltl formulae { []((to_send_move.direction == UP -> (matrix[to_send_move.line_number-2].column[to_send_move.column_number] == 1 && matrix[to_send_move.line_number-1].column[to_send_move.column_number] == 1)) &&
              (to_send_move.direction == DOWN -> (matrix[to_send_move.line_number+2].column[to_send_move.column_number] == 1 && matrix[to_send_move.line_number+1].column[to_send_move.column_number] == 1)) &&
              (to_send_move.direction == LEFT -> (matrix[to_send_move.line_number].column[to_send_move.column_number-2] == 1 && matrix[to_send_move.line_number].column[to_send_move.column_number-1] == 1)) &&
              (to_send_move.direction == RIGHT -> (matrix[to_send_move.line_number].column[to_send_move.column_number+2] == 1 && matrix[to_send_move.line_number].column[to_send_move.column_number+1] == 1))U(!(number_pegs == 1)))}
